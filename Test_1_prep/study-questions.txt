CS 4310 study questions

Slides I
- Determine frequency counts for the statements of a given program
section, total frequency count or order of the total frequency
count.
- Prove by induction on n that  sum_i=1^n i = n(n+1)/2.
- Other induction proofs.
- Order of complexity, define:   f(n) = O(g(n))
                                 f(n) = Big Omega(g(n))
                                 f(n) = Big Theta(g(n))
                                 f(n) = little omega(g(n))
  for non-negative functions functions f(n) and g(n), using the
  definition.
- Problems regarding order of complexity.
- Apply Theorem [Ratios] for given functions.
- Define:  f(n) = little o(g(n))
           f(n) = little omega(g(n)) 

Slides II
- What is a divide-and-conquer method?
- Give a binary search algorithm (pseudocode).
- Give a recurrence relation for the worst-case time of binary
  search, and solve (assuming n is a power of 2). Also check 
  whether the solution is valid.
- Give a pseudocode for merge sort.
- Give a recurrence relation for the worst-case time of merge
  sort as a function of the array size n, and solve (assuming n 
  is a power of 2). 
- Show that the time T(n) for merge sort satisfies:
  T(n) = O(n log n) where n is a power of 2.
- Give a (recursive) algorithm for quicksort (pseudocode).
  Give three methods for determining the pivot element in 
  partition.
- Give a recurrence relation for the worst-case time of quicksort,
  and a scenario under which this happens. 
- Give a formula for the average time Av(n) of quicksort.
  What is its order of complexity?
- Give an algorithm (pseudocode) for randomized quicksort.
  How is the randomization taken? What is its expected time E(n)?
- Give a divide-and-conquer matrix multiplication for two nxn
  matrices, and derive its complexity (order) for n a power of 2, 
  in terms of the number of multiplications.
- Give a divide-and-conquer matrix multiplication for two nxn
  matrices, and derive its complexity (order) for n a power of 2, 
  in terms of the number of multiplications and additions.
- For Strassen's matrix multiplication of two nxn matrices, give 
  a recurrence relation with respect to the number of 
  multiplications and solve to determine the complexity order.
- For Strassen's matrix multiplication of two nxn matrices, give 
  a recurrence relation with respect to the number of additions
  and multiplications and solve to determine the complexity order.

Slides III
- Give an algorithm for k-th order selection (and partition) to 
  determine the k-th smallest element of an array of size n.
- Derive the worst-case time for k-th order selection, and a 
  scenario under which this happens. 
  What is the complexity of the average-case time, under what
  assumptions?
- Give an algorithm (pseudocode) for k-th order selection to 
  determine the k-th smallest element.
- Describe the median-of-medians method for k-th order selection,
  where the array size n is an odd multiple of 5.
  Give an example (picture) and explain.
- Give an algorithm (pseudocode) for median-of-medians selection,
  and partition function. What is the order of the worst-case time
  complexity? 
- Solve recurrence relations (homogeneous, nonhomogeneous) using
  the characteristic equation.


CS 4310 study questions/topics
  
Slides IV
- Give a general outline of the greedy meta-algorithm.
- What is a greedy algo in general (what does it do)?
  Define: objective function, constraint, feasible sol., optimal sol.
- Define the greedy knapsack problem.
- Solve a greedy knapsack problem.
- Give greedy knapsack algo. pseudocode.
  What is its complexity?
- Define the optimal merge pattern problem.
  What quantity is optimized? Define.
- Define the weighted external path length.
- Solve an optimal merge pattern problem.
- Give an algorithm for the optimal merge pattern problem (pseudocode).
  Discuss its complexity (using a heap or linked list).
- Define the Huffman tree problem.
  What quantity is optimized? Define.
- Solve a Huffman tree problem.
- Give an algorithm for the Huffman tree problem (pseudocode).
  Discuss its complexity (using a heap or linked list).
- All graphs terminology.
- Give two graph representations.
  Discuss the space they need.
- What is a spanning tree of an undirected graph?
- What is a min. cost spanning tree of an undirected graph?
- Solve a min. cost spanning tree problem
  . using Kruskal's algo
  . using Prim's algo
- Give a high-level representation of Kruskal's algo.
- Discuss its complexity.
- Give pseudocode + complexity of heapify() for building heap.
- Give a detailed representation of Kruskal's algo using union-find.
- All union-find def.
- Outline union-find representation, apply to example.
- Outline simple union and simple find procedures (pseudocode).
- Discuss/show inefficiency of using simple union and simple find.
- Outline weighted union and collapsing find procedures (pseudocode).
- State lemma regarding tree depth and prove lemma
- Kruskal's algo. complexity using heap, and using union-find for
  detecting cycles.
  
